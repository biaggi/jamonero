'use strict';

var querystring = require('querystring');
var https = require('https');
var chalk = require('chalk');
var fs = require('fs');
var nopt = require('nopt');
var path = require('path');

var EOL = require('os').EOL;

var options = nopt(
  {
    'quiet': Boolean,
    'login': Boolean,
    'pattern': String,
    'repo': String,
    'project': String,
    'help': Boolean
  },
  {
    '-q': ['--quiet'],
    '-l': ['--login'],
    '-r': ['--repo'],
    '-p': ['--project'],
    '-?': ['--help'],
    '-h': ['--help']
  }
);

if (!options.argv.remain.length || options.help) {
  console.log([
    'stash2repoconfig: creates a config file with the info of the repos in stash',
    '',
    'Usage:',
    '  stash2repoconfig <user>:<password> [OPTIONS]',
    '',
    '    <user>:<password> with the stash username and password',
    '',
    'Options:',
    '  --base64, -b: <user>:<password> base64 encoded',
    '  --login, -l: Force login in stash',
    '  --quiet, -q: Only print errors and success messages',
    '  --pattern, -p: Search repositories match with a pattern. Default: no pattern',
    '  --repo, -r: Output file with repositories configuration. Default: cells.json',
    '  --project, -p: Short name of the project. Default: pgev',
    '  --help, -h: Print this message',
    '',
    'Examples:',
    ' $ node ./stash2repoconfig.js e023375:stashpassword --pattern cell',
    ' $ node ./stash2repoconfig.js --help'
  ].join(EOL));
  process.exit();
}

if (!options.pattern) {
  options.pattern = '';
}

if (!options.repo) {
  options.repo = '../repo-configs/cells.json';
}

if (!options.project) {
  options.project = 'cel';
}

var userPassword = options.argv.remain[0];
if( options.base64 )
{
  getReposFromStash(true, getReposFromJson);
}
else
{
  var arrUserPass = userPassword.split(':');
  if (arrUserPass.length == 2) {
    getReposFromStash(false, getReposFromJson);
  }
  else {
    if (!options.quiet) {
      console.log(chalk.red.bold('FAILED. Invalid sintax with user and pasword'));
    }
  }
}

function loginStash(user, password) {

  if( !user ) {
    console.error('User is required');
    return;
  }
  if( !password ) {
    console.error('Password is required');
    return;
  }
  var data = querystring.stringify({
    j_username: user,
    j_password: password,
    submit: 'Log+in'
  });

  var reqOptions = {
    host: 'descinet.bbva.es',
    port: '443',
    path: '/stash/j_stash_security_check',
    method: 'POST',
    headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'Content-Length': Buffer.byteLength(data)
    }
  };

  var req = https.request(reqOptions, function(res) {
      res.setEncoding('utf8');
      if (!options.quiet) {
        console.log(chalk.blue('==='), chalk.blue.bold('Stash login'), chalk.blue('==='));
      }

      res.on('data', function (chunk) {
      });

      res.on('end', function() {
        if (!options.quiet) {
          console.log(chalk.green.bold('login OK'));
        }
      });
  });

  req.write(data);
  req.end();

  req.on('error', function(e) {
    if (!options.quiet) {
      console.log(chalk.red.bold('FAILED'));
      console.error(chalk.red(e));
    }
  });
}

function getReposFromStash(base64, callback) {
  if (options.login) {
    if(base64) {
      console.error('Force login and base64 is not compatible');
    } else {
      loginStash(arrUserPass[0], arrUserPass[1]);
    }
  }

  var ret = '';
  var stashRepos = {};
  var reqOptions = {
    host: 'descinet.bbva.es',
    port: '443',
    path: '/stash/rest/api/1.0/projects/' + options.project + '/repos?limit=1000',
    method: 'GET',
    // auth: arrUserPass[0] + ':' + arrUserPass[1],
    headers: {
      //'Cookie': 'crowd.token_key=on6CW1zPN4h4eft3lJUvCg00',
      'Content-Type': 'application/json',
      'Content-Length': 10000
    }
  };

  if( base64 ) {
    reqOptions.headers['Authorization'] = 'Basic ' + userPassword;
  } else {
    reqOptions.auth = arrUserPass[0] + ':' + arrUserPass[1];
  }

  var req = https.request(reqOptions, function(res) {
    if (!options.quiet) {
      console.log(chalk.blue('==='), chalk.blue.bold('Getting repos from stash'), chalk.blue('==='));
    }

    res.on('data', function(chunk) {
      ret += chunk;
    });

    res.on('end', function() {
      stashRepos = JSON.parse(ret);
      if (!options.quiet) {
        if (ret !== '' && !stashRepos.errors) {
          console.log(chalk.green.bold('OK ' + stashRepos.values.length + ' repos from stash'));
        } else if (ret !== ''){
          console.log(chalk.red.bold('FAILED no repos from stash'));
          console.log(stashRepos.errors);
        } else {
          console.log(chalk.red.bold('FAILED no repos from stash'));
        }
      }
      callback(stashRepos);
    });

  });
  req.end();

  req.on('error', function(e) {
    if (!options.quiet) {
      console.log(chalk.red.bold('FAILED'));
      console.error(chalk.red(e));
    }
  });
}

function getReposFromJson(repos) {
  if (!options.quiet) {
    console.log(chalk.blue('==='), chalk.blue.bold('Generating Config'), chalk.blue('==='));
  }

  var output = [
    {
      'dir': 'components',
      'org': '',
      'url': 'descinet.bbva.es/stash/scm/' + options.project,
      'repos': []
    } ,{
      'dir': 'projects',
      'org': '',
      'url': 'descinet.bbva.es/stash/scm/' + options.project,
      'repos': []
    } ,{
      'dir': '',
      'org': '',
      'url': 'descinet.bbva.es/stash/scm/' + options.project,
      'repos': []
    } ,{
      'dir': 'toolkit',
      'org': '',
      'url': 'descinet.bbva.es/stash/scm/' + options.project,
      'repos': []
    }
  ];

  if(repos.values) {
    var count = 0;
    repos.values.forEach(function(repo){
      var regPattern = new RegExp(options.pattern, 'g');
      var cellsToolKitRepos = [
        'generator-cells-cordova.git',
        'generator-cells-starter-kit',
        'generator-cells-cordova',
        'cells-serve',
        'cells-seed',
        'cells-starter-kit',
        'cells-back-loader',
        'cells-back-services',
        'cells-back-tools',
        'cells-back-vagrant'
      ];
      var found = regPattern.exec(repo.name, 'g');

      //console.log('project: %s - repo: %s', repo.project.key, repo.name);
      var isProject = ('BBVACELLSAPP' === repo.project.key);

      var isTools = ('CEL' === repo.project.key && repo.name === 'tools');

      var isToolKit = ('CEL' === repo.project.key && !isTools && ~cellsToolKitRepos.indexOf(repo.name));

      // var isComp = !isTools && !isToolKit && ('CELCOM' === repo.project.key || 'BBVACELLSAPI' === repo.project.key); // && ~cellsCompsRepos.indexOf(repo.name));
      // var isComp = ('CELCOM' === repo.project.key || 'BBVACELLSAPI' === repo.project.key && ~cellsCompsRepos.indexOf(repo.name));
      var isComp = ( 'CEL' === repo.project.key && !isTools && !isToolKit) || ('CELCOM' === repo.project.key || 'BBVACELLSAPI' === repo.project.key);

      // console.log('isProject: %s | isTools: %s | isToolKit: %s | isComp: %s', isProject, isTools, isToolKit, isComp);

      if (found && found.length != 0) {
        count ++;
        if (isComp){
          output[0].repos.push(repo.name + '.git');
        } else if (isProject) {
          output[1].repos.push(repo.name + '.git');
        } else if (isTools) {
          output[2].repos.push(repo.name + '.git');
        } else if (isToolKit){
          output[3].repos.push(repo.name + '.git');
        }
      }
    });
    if (!options.quiet) {
      console.log(chalk.green.bold('Found ' + count + ' repositories'));
    }

    writeFile(output);
  } else {
    if (!options.quiet) {
      console.log(chalk.red.bold('FAILED no repositories founds'));
    }
  }
}

function writeFile(dataJson) {
  if (!options.quiet) {
    console.log(chalk.blue('==='), chalk.blue.bold('Writing file'), chalk.blue('==='));
  }

  fs.writeFile(options.repo, JSON.stringify(dataJson, null, 2), function(err) {
      if(err) {
        if (!options.quiet) {
          console.log(chalk.green.bold('FAILED saving file'));
          console.log(chalk.red.err);
        }
      } else {
        if (!options.quiet) {
          console.log(chalk.green.bold('COMPLETED saved ' + path.basename(options.repo)));
          console.log(chalk.green.bold(' ' + options.repo));
        }
      }
  });
}
